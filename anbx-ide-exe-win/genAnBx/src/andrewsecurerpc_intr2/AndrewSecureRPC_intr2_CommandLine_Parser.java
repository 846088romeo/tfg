
/*

 AnBx Compiler and Code Generator

 Copyright 2011-2025 Paolo Modesti
 Copyright 2018-2025 SCM/SCDT/SCEDT, Teesside University
 Copyright 2016-2018 School of Computer Science, University of Sunderland
 Copyright 2013-2015 School of Computing Science, Newcastle University
 Copyright 2011-2012 DAIS, Universita' Ca' Foscari Venezia
 
 This file was automatically generated by the AnBx Compiler 2025.01 on 2025-03-27 09:06:15.5204529 UTC -->

 AnBx is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.

 AnBx is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with AnBx. If not, see <http://www.gnu.org/licenses/>.

*/

package andrewsecurerpc_intr2;

import anbxj.AnBx_CommandLine_Parser;
import anbxj.AnBx_Debug;
import anbxj.AnBx_Layers;
import anbxj.Channel_Settings;

import java.util.HashMap;
import java.util.Map;

public final class AndrewSecureRPC_intr2_CommandLine_Parser extends AnBx_CommandLine_Parser<AndrewSecureRPC_intr2_Roles,AndrewSecureRPC_intr2_Channels> {

	public AndrewSecureRPC_intr2_CommandLine_Parser(String[] args, String prot) {
		super(args, prot, prot, AndrewSecureRPC_intr2_Roles.class, true);
		// AnBx_Debug.setAPPLICATION(true);
		// AnBx_Debug.setPROTOCOL(true);
		// AnBx_Debug.setSESSION(true);
		// AnBx_Debug.setLANGUAGE(true);
		// AnBx_Debug.setENCRYPTION(true);
		// AnBx_Debug.setBUSINESS_LOGIC(true);
		// AnBx_Debug.setALL(true);
    		initProtocol();
	}

	protected void initProtocol() {

		Map<String, Channel_Settings> cs = new HashMap<String, Channel_Settings>();
		Map<String, String> aliases = new HashMap<String, String>();
		AndrewSecureRPC_intr2_Principal AndrewSecureRPC_intr2_pr = null;
        if (role == null) terminate("no or incorrect role specified");
		AnBx_Debug.setAppname(role.toString());
		initRole(ct, role, cs, aliases, AndrewSecureRPC_intr2_Roles.class, AndrewSecureRPC_intr2_Channels.class);
		AnBx_Debug.out(layer, "myRole: " + role);
        AnBx_Debug.out(layer, "sessions: " + sessions);

		if (myAlias != null && keypath != null && sharepath != null) {
			AndrewSecureRPC_intr2_pr = new AndrewSecureRPC_intr2_Principal(myAlias, keypath, cs, aliases, crypto_config);
			switch (role) {
			case ROLE_A:
				AndrewSecureRPC_intr2_pr.run(new AndrewSecureRPC_intr2_ROLE_A(role, protname, sharepath),sessions);
				break;
			case ROLE_B:
				AndrewSecureRPC_intr2_pr.run(new AndrewSecureRPC_intr2_ROLE_B(role, protname, sharepath),sessions);
				break;
			case ROLE_intr:
				AndrewSecureRPC_intr2_pr.run(new AndrewSecureRPC_intr2_ROLE_intr(role, protname, sharepath),sessions);
				break;
			
            default:
				break;
			}
		} else terminate("Unable to initialize " + protname + " Principal");
	}
}