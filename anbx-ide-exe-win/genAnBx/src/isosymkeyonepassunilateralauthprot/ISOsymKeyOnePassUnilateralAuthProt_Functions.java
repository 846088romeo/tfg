/*

 AnBx Compiler and Code Generator

 Copyright 2011-2025 Paolo Modesti
 Copyright 2018-2025 SCM/SCDT/SCEDT, Teesside University
 Copyright 2016-2018 School of Computer Science, University of Sunderland
 Copyright 2013-2015 School of Computing Science, Newcastle University
 Copyright 2011-2012 DAIS, Universita' Ca' Foscari Venezia
 
 This file was automatically generated by the AnBx Compiler 2025.01 on 2025-02-04 11:59:04.2161377 UTC -->

 AnBx is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.

 AnBx is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with AnBx. If not, see <http://www.gnu.org/licenses/>.

*/

package isosymkeyonepassunilateralauthprot;

import anbxj.AnBx_Debug;
import anbxj.AnBx_Layers;
import anbxj.AnBx_Params;
import anbxj.AnB_Protocol;
import anbxj.AnB_Session;
import anbxj.Crypto_KeyStoreType;
import anbxj.Crypto_ByteArray;
import anbxj.Crypto_HmacPair;
import anbxj.Crypto_SealedPair;
import anbxj.Crypto_KeyPair;

import java.io.Serializable;
import java.util.Objects;
import java.security.KeyPair;
import java.security.PublicKey;
import java.security.SignedObject;
import javax.crypto.SealedObject;
import javax.crypto.SecretKey;
import javax.crypto.spec.DHParameterSpec;

import java.util.Map;
import java.util.Random;
import java.math.BigInteger;

//generic random generator function for custom types
class RandomCrypto_ByteArray implements Serializable {

	private static final long serialVersionUID = 1L;
	protected Crypto_ByteArray random_cba;
	
	RandomCrypto_ByteArray() { 
		random_cba = new Crypto_ByteArray(Integer.toString(new Random().nextInt()).getBytes());
	}

	@Override
	public int hashCode() {
		return Objects.hash(random_cba);
	}

	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		RandomCrypto_ByteArray other = (RandomCrypto_ByteArray) obj;
		return Objects.equals(random_cba, other.random_cba);
	}
}

// custom types


public final class ISOsymKeyOnePassUnilateralAuthProt_Functions {
	
	// add here your public static functions

	public static Crypto_ByteArray pre(AnB_Session s,Crypto_ByteArray par1) {
		return pre(par1);
	}

    public static Crypto_ByteArray succ(AnB_Session s,Crypto_ByteArray par1) {
        return succ(par1);
    }

	public static Crypto_ByteArray add(AnB_Session s,Crypto_ByteArray par1,Crypto_ByteArray par2) {
		return add (par1,par2);
	}
    
    public static Crypto_ByteArray sub(AnB_Session s,Crypto_ByteArray par1,Crypto_ByteArray par2) {	
		return sub(par1,par2);
	}    
    
	public static Crypto_ByteArray pre (Crypto_ByteArray cba) {
		BigInteger n = new BigInteger(1,cba.getByteArray());
		n = n.subtract(new BigInteger("1"));
		return new Crypto_ByteArray(trim(n));
	}
	
	public static Crypto_ByteArray succ (Crypto_ByteArray cba) {
		BigInteger n = new BigInteger(1,cba.getByteArray());
		n = n.add(new BigInteger("1"));
		return new Crypto_ByteArray(trim(n));
    }
	
	public static Crypto_ByteArray add (Crypto_ByteArray cba1,Crypto_ByteArray cba2) {
		BigInteger n1 = new BigInteger(1,cba1.getByteArray());
		BigInteger n2 = new BigInteger(1,cba2.getByteArray());
		BigInteger n = n1.add(n2);
		return new Crypto_ByteArray(trim(n));
	}
	
	public static Crypto_ByteArray sub (Crypto_ByteArray cba1,Crypto_ByteArray cba2) {
		BigInteger n1 = new BigInteger(1,cba1.getByteArray());
		BigInteger n2 = new BigInteger(1,cba2.getByteArray());
		BigInteger n = n1.subtract(n2);
		return new Crypto_ByteArray(trim(n));
	}
	
    public static final byte[] trim(BigInteger n) {
        byte[] input = n.toByteArray();
        int len = input.length;
        int i = 0;
        while (i < len && input[i] == 0) {
            ++i;
        }
        if (i == len) {
            return new byte[]{0};
        }
        byte[] result = new byte[len - i];
        System.arraycopy(input, i, result, 0, len - i);
        return result;
    }

	// --------------------------------------
    
    // auto-generated public functions
	
	

}