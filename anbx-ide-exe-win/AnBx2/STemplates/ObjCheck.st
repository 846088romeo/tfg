/*

 AnBx Compiler and Code Generator

 Copyright 2011-2025 Paolo Modesti
 Copyright 2018-2025 SCM/SCDT/SCEDT, Teesside University
 Copyright 2016-2018 School of Computer Science, University of Sunderland
 Copyright 2013-2015 School of Computing Science, Newcastle University
 Copyright 2011-2012 DAIS, Universita' Ca' Foscari Venezia
 
 This file was automatically generated by the AnBx Compiler $if(showverdatetime)$$version$ on $datetime$ $endif$-->

 AnBx is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.

 AnBx is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with AnBx. If not, see <http://www.gnu.org/licenses/>.

*/

package $package$;

import anbxj.AnBx_Debug;
import anbxj.AnBx_Layers;
import anbxj.AnBx_Params;
import anbxj.AnB_Protocol;
import anbxj.AnB_Session;
import anbxj.Crypto_KeyStoreType;
import anbxj.Crypto_ByteArray;
import anbxj.Crypto_HmacPair;
import anbxj.Crypto_SealedPair;
import anbxj.Crypto_KeyPair;
import anbxj.AnB_Crypto_Wrapper;

import java.security.KeyPair;
import java.security.PublicKey;
import java.security.SignedObject;
import javax.crypto.SealedObject;
import javax.crypto.SecretKey;
import javax.crypto.spec.DHParameterSpec;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Comparator;

/* 
This application allows to check reconstructed serialised objects streams stored as $serExt$ files 
Expected FileName: $prot$_STREAM_#$serExt$  
*/

public class $prot$_ObjCheck {

	final static AnBx_Layers layer = AnBx_Layers.APPLICATION;

    final static $prot$_Steps[] steps = {
	        $steps:{n|$prot$_Steps.$n.step$};separator=", "$
	    };

    final static $prot$_Channels[] channels = {
	        $channels:{n|$prot$_Channels.$n$};separator=", "$
	    };
    
    final static Map<$prot$_Steps, $prot$_Channels> channelStepMap = new HashMap<>();
        static {
            $channelsteps:{n|channelStepMap.put($prot$_Steps.$n.step$, $prot$_Channels.$n.channel$);
            }$}

    public static void main(String[] args) {
        
        AnBx_Debug.setAppname("$prot$");
        AnBx_Debug.setAPPLICATION(true);
		
		readStreams("$prot$_STREAM_.*\\\\.ser");
		// readStreams("$prot$_STEP_.*\\\\.ser");
       
        executeSteps();
        AnBx_Debug.out(layer, "--- Check completed ---");
	}

	protected static void executeSteps() {

		AnBx_Debug.out(layer, "--- Executing Steps ---");
        for ($prot$_Steps step : steps) {
        try {
                executeStep(step);
            } catch (ClassCastException e) {
                handleException("Message format type error", e);
            } catch (NullPointerException e) {
                handleException("Some data have not been properly initialised", e);
            } catch (Exception e) {
                handleException("Generic error", e);
		    }
        }
    }    

	protected static void executeStep($prot$_Steps step) {

        $prot$_Channels channel = null;
		status(step);

		switch (step) {

            $steps:{n|case $n.step$:
                
                channel = channelStepMap.get(step);
                $n.objtype$ VAR_$n.step$ = ($n.objtype$) AnB_Crypto_Wrapper.readObject("$prot$_" + step.toString() + "$serExt$");
                AnBx_Debug.out(layer, "Step: " +  step.toString() + " - Channel: " + channel + " - Message: " + VAR_$n.step$.toString());
                break;

            }$
		default:
			break;
		}

		status(step);
        
	}

	protected static void handleException(String msg, Exception e) {
		AnBx_Debug.out(AnBx_Layers.ALWAYS, " ----------------- Protocol Error ------------------- ");
		AnBx_Debug.out(AnBx_Layers.ALWAYS, "Protocol: " + "$prot$");
		AnBx_Debug.out(AnBx_Layers.ALWAYS, "Error: " + msg);
		if (e != null) {
			AnBx_Debug.out(AnBx_Layers.ALWAYS, "Error description: " + e.toString());
			e.printStackTrace();
		}
		AnBx_Debug.out(AnBx_Layers.ALWAYS, " ----------------- Protocol Error ------------------- ");
	}

   	protected static void handleException(String msg, Exception e, Boolean terminate) {
		handleException(msg, e);
		if (terminate) System.exit(1);
	}


	protected static void status($prot$_Steps step) {
		AnBx_Debug.out(layer, "Step: " + step.toString());
	}
	
    protected static void readStreamsSimple(String filepattern) {
        List<Map.Entry<Integer, Object>> streamObjects = readFilesWithPattern(filepattern);
        
        for (Map.Entry<Integer, Object> entry : streamObjects) {
            int streamNumber = entry.getKey();
            Object obj = entry.getValue();
            AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Object: " + obj);
        }
    }

    protected static void readStreams(String filepattern) {
        
        AnBx_Debug.out(layer, "--- Reading Streams ---");

        List<Map.Entry<Integer, Object>> streamObjects = readFilesWithPattern(filepattern);
        
        if (streamObjects.size() != steps.length) {
            handleException("Number of objects (\" + streamObjects.size() + \") does not match the number of steps (" + steps.length + ")", null, true);
        } else {
        
            AnBx_Debug.out(layer, "--- Matching Messages and Steps ---");
            // Map to keep track of the steps already seen for each channel
            Map<$prot$_Channels, List<$prot$_Steps>> channelStepsSeenMap = new HashMap<>();
            String filename = null;
            
            for (Map.Entry<Integer, Object> entry : streamObjects) {
                int streamNumber = entry.getKey();
                Object obj = entry.getValue();
                
                // Find the channel corresponding to the stream number
                $prot$_Channels channel = channels[streamNumber]; 
                
                AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Channel: " + channel.toString());
                
                // Get the list of steps already seen for the current channel
                List<$prot$_Steps> stepsSeen = channelStepsSeenMap.getOrDefault(channel, new ArrayList<>());
                
                // Retrieve the steps associated with the current channel from the channelStepMap
                $prot$_Steps[] steps = channelStepMap.entrySet().stream()
                                                .filter(e -> e.getValue() == channel)
                                                .map(Map.Entry::getKey)
                                                .sorted(Comparator.comparingInt(Enum::ordinal)) // Sort steps by their ordinal value
                                                .toArray($prot$_Steps[]::new);
                
                // Find the first step in the list of steps associated with the channel that hasn't been seen yet
                $prot$_Steps currentStep = null;
                for ($prot$_Steps step : steps) {
                    if (!stepsSeen.contains(step)) {
                        currentStep = step;
                        break;
                    }
                }
                
                // If no unseen steps are found, raise an error
                if (currentStep == null) {
                    handleException("Step not found for Object: " + obj, null, true);
                }
                
                // Update the list of steps already seen for the current channel
                stepsSeen.add(currentStep);
                channelStepsSeenMap.put(channel, stepsSeen);

                AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Step: " + currentStep + " - Object: " + obj.toString());
                // save the object in serialised file
                filename = "$prot$_" + currentStep + "$serExt$";
                AnB_Crypto_Wrapper.writeObject(obj,filename);
                AnBx_Debug.out(layer, "Saving " + filename);
            }
        }
    }

    public static List<Map.Entry<Integer, Object>> readFilesWithPattern(String pattern) {
            List<Map.Entry<Integer, Object>> objects = new ArrayList<>();
            int streamNumber = 0;

            File folder = new File(".");
            File[] listOfFiles = folder.listFiles((dir, name) -> name.matches(pattern));
            
            if (listOfFiles.length != channels.length) {
                handleException("Warning: Number of stream files (" + listOfFiles.length + ") does not match the number of channels (" + channels.length + ")", null, false);
            } else {
            
                    if (listOfFiles != null) {
                        for (File file : listOfFiles) {
                            AnBx_Debug.out(layer, "File: " + file.getName().toString());
                            try (FileInputStream fi = new FileInputStream(file);
                                ObjectInputStream oi = new ObjectInputStream(fi)) {

                                int objectNumber = 1;
                                while (true) {
                                    Object x = oi.readObject();
                                    AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Object #" + objectNumber + ": " + x.getClass().toString() + " - " +  x.toString());
                                    objects.add(Map.entry(streamNumber, x));
                                    objectNumber++;
                                }
                            } catch (EOFException e) {
                            } catch (FileNotFoundException e) {
                                System.out.println("File not found: " + file.getName());
                                e.printStackTrace();
                            } catch (IOException e) {
                                System.out.println("IO exception: " + file.getName());
                                e.printStackTrace();
                            } catch (ClassNotFoundException e) {
                                System.out.println("Class not found: " + file.getName());
                                e.printStackTrace();
                            }
                            streamNumber++;
                        }
                    }
                }
                return objects;
        }    
        
    }