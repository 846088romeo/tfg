Protocol: Kerberos_PKINIT_intr AnB

Types:
	Agent C,ath,gw,s;
	Number N1,N2,T0,T1,T2,Payload,tag,trash;
	Function [Agent -> PublicKey] pk,sk;
	Function [Untyped -> Number] hash;
	Symmetric_key KCG,KCS,Ktemp;
	Function [Agent,Agent ->* SymmetricKey] shk;
	Agent intr;

Knowledge:
	C: C,ath,gw,s,sk(ath),sk(C),inv(sk(C)),pk(C),inv(pk(C)),hash,tag,pk,sk;
	ath: C,ath,gw,pk(C),sk(ath),inv(sk(ath)),hash,tag,shk(ath,gw),intr,pk(intr);
	gw: ath,s,gw,hash,tag,shk(gw,s),shk(ath,gw);
	s: gw,s,hash,tag,shk(gw,s);
	intr: intr,ath,gw,s,sk(ath),sk(intr),inv(sk(intr)),pk(intr),inv(pk(intr)),hash,tag,pk,sk;
	gw,s share shk(gw,s);
	ath,gw share shk(ath,gw);
	C,ath share sk(ath),pk(C);
	ath,C share pk(C),sk(ath);
	where C!=ath, C!=intr

Actions:
	C -> intr: C,gw,N1,{T0,N1,hash(C,gw,N1)}inv(sk(C))
	intr -> ath: intr,gw,N1,{T0,N1,hash(intr,gw,N1)}inv(sk(intr))
#	intr cambia el origen para que ath utilice su pk

	ath -> intr: intr,{|ath,intr,gw,KCG,T1|}shk(ath,gw),{|gw,KCG,T1,N1|}Ktemp,{tag,{Ktemp}inv(sk(ath))}pk(intr)
	intr -> C: C,{|ath,intr,gw,KCG,T1|}shk(ath,gw),{|gw,KCG,T1,N1|}Ktemp,{tag,{Ktemp}inv(sk(ath))}pk(C)
#	intr vuelve a cambiar a C para que C no sepa que está siendo suplantado

	C -> intr: s,N2,{|ath,intr,gw,KCG,T1|}shk(ath,gw),{|C,T1|}KCG
	
	intr -> gw: s,N2,{|ath,intr,gw,KCG,T1|}shk(ath,gw),{|intr,T1|}KCG
	gw -> intr: intr,{|intr,s,KCS,T2|}shk(gw,s),{|s,KCS,T2,N2|}KCG
#	Intercepción de un ticket para su uso posterior


#	Secuencia normal con intruso pasivo, en el activo ahora solo se comunica con C
#	intr -> C: C,{|C,s,KCS,T2|}shk(gw,s),{|s,KCS,T2,N2|}KCG
#	C -> intr: {|C,s,KCS,T2|}shk(gw,s),{|C,hash(T2)|}KCS
#	intr -> s: {|C,s,KCS,T2|}shk(gw,s),{|C,hash(T2)|}KCS
#	s -> intr: {|hash(T2)|}KCS,{|tag,Payload|}KCS
#	intr -> C: {|hash(T2)|}KCS,{|tag,Payload|}KCS

	intr -> C: C,{|intr,s,KCS,T2|}shk(gw,s),{|s, KCS, T2, N2|}KCG
	C -> intr: {|intr,s,KCS,T2|}shk(gw,s),{|C, hash(T2)|}KCS
	intr -> C: {|hash(T2)|}KCS, {|tag, Payload|}KCS

Goals:
	intr *->* C: Payload
