/*

 AnBx Compiler and Code Generator

 Copyright 2011-2025 Paolo Modesti
 Copyright 2018-2025 SCM/SCDT/SCEDT, Teesside University
 Copyright 2016-2018 School of Computer Science, University of Sunderland
 Copyright 2013-2015 School of Computing Science, Newcastle University
 Copyright 2011-2012 DAIS, Universita' Ca' Foscari Venezia
 
 This file was automatically generated by the AnBx Compiler 2025.01 on 2025-02-04 11:58:45.6785419 UTC -->

 AnBx is free software: you can redistribute it and/or modify
 it under the terms of the GNU General Public License as published by
 the Free Software Foundation, either version 3 of the License, or
 any later version.

 AnBx is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 GNU General Public License for more details.

 You should have received a copy of the GNU General Public License
 along with AnBx. If not, see <http://www.gnu.org/licenses/>.

*/

package anbx_from_a_secret_for_b_c_honest;

import anbxj.AnBx_Debug;
import anbxj.AnBx_Layers;
import anbxj.AnBx_Params;
import anbxj.AnB_Protocol;
import anbxj.AnB_Session;
import anbxj.Crypto_KeyStoreType;
import anbxj.Crypto_ByteArray;
import anbxj.Crypto_HmacPair;
import anbxj.Crypto_SealedPair;
import anbxj.Crypto_KeyPair;
import anbxj.AnB_Crypto_Wrapper;

import java.security.KeyPair;
import java.security.PublicKey;
import java.security.SignedObject;
import javax.crypto.SealedObject;
import javax.crypto.SecretKey;
import javax.crypto.spec.DHParameterSpec;

import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.util.ArrayList;
import java.util.List;
import java.util.HashMap;
import java.util.Map;
import java.util.Comparator;

/* 
This application allows to check reconstructed serialised objects streams stored as .ser files 
Expected FileName: AnBx_From_A_secret_for_B_C_honest_STREAM_#.ser  
*/

public class AnBx_From_A_secret_for_B_C_honest_ObjCheck {

	final static AnBx_Layers layer = AnBx_Layers.APPLICATION;

    final static AnBx_From_A_secret_for_B_C_honest_Steps[] steps = {
	        AnBx_From_A_secret_for_B_C_honest_Steps.STEP_0, AnBx_From_A_secret_for_B_C_honest_Steps.STEP_1
	    };

    final static AnBx_From_A_secret_for_B_C_honest_Channels[] channels = {
	        AnBx_From_A_secret_for_B_C_honest_Channels.ROLE_B_channel_ROLE_A_Server_Insecure, AnBx_From_A_secret_for_B_C_honest_Channels.ROLE_A_channel_ROLE_B_Client_Insecure, AnBx_From_A_secret_for_B_C_honest_Channels.ROLE_c_channel_ROLE_B_Server_Insecure, AnBx_From_A_secret_for_B_C_honest_Channels.ROLE_B_channel_ROLE_c_Client_Insecure
	    };
    
    final static Map<AnBx_From_A_secret_for_B_C_honest_Steps, AnBx_From_A_secret_for_B_C_honest_Channels> channelStepMap = new HashMap<>();
        static {
            channelStepMap.put(AnBx_From_A_secret_for_B_C_honest_Steps.STEP_0, AnBx_From_A_secret_for_B_C_honest_Channels.ROLE_B_channel_ROLE_A_Server_Insecure);
            channelStepMap.put(AnBx_From_A_secret_for_B_C_honest_Steps.STEP_1, AnBx_From_A_secret_for_B_C_honest_Channels.ROLE_c_channel_ROLE_B_Server_Insecure);
            }

    public static void main(String[] args) {
        
        AnBx_Debug.setAppname("AnBx_From_A_secret_for_B_C_honest");
        AnBx_Debug.setAPPLICATION(true);
		
		readStreams("AnBx_From_A_secret_for_B_C_honest_STREAM_.*\\.ser");
		// readStreams("AnBx_From_A_secret_for_B_C_honest_STEP_.*\\.ser");
       
        executeSteps();
        AnBx_Debug.out(layer, "--- Check completed ---");
	}

	protected static void executeSteps() {

		AnBx_Debug.out(layer, "--- Executing Steps ---");
        for (AnBx_From_A_secret_for_B_C_honest_Steps step : steps) {
        try {
                executeStep(step);
            } catch (ClassCastException e) {
                handleException("Message format type error", e);
            } catch (NullPointerException e) {
                handleException("Some data have not been properly initialised", e);
            } catch (Exception e) {
                handleException("Generic error", e);
		    }
        }
    }    

	protected static void executeStep(AnBx_From_A_secret_for_B_C_honest_Steps step) {

        AnBx_From_A_secret_for_B_C_honest_Channels channel = null;
		status(step);

		switch (step) {

            case STEP_0:
                
                channel = channelStepMap.get(step);
                Crypto_SealedPair VAR_STEP_0 = (Crypto_SealedPair) AnB_Crypto_Wrapper.readObject("AnBx_From_A_secret_for_B_C_honest_" + step.toString() + ".ser");
                AnBx_Debug.out(layer, "Step: " +  step.toString() + " - Channel: " + channel + " - Message: " + VAR_STEP_0.toString());
                break;

            case STEP_1:
                
                channel = channelStepMap.get(step);
                Crypto_SealedPair VAR_STEP_1 = (Crypto_SealedPair) AnB_Crypto_Wrapper.readObject("AnBx_From_A_secret_for_B_C_honest_" + step.toString() + ".ser");
                AnBx_Debug.out(layer, "Step: " +  step.toString() + " - Channel: " + channel + " - Message: " + VAR_STEP_1.toString());
                break;

            
		default:
			break;
		}

		status(step);
        
	}

	protected static void handleException(String msg, Exception e) {
		AnBx_Debug.out(AnBx_Layers.ALWAYS, " ----------------- Protocol Error ------------------- ");
		AnBx_Debug.out(AnBx_Layers.ALWAYS, "Protocol: " + "AnBx_From_A_secret_for_B_C_honest");
		AnBx_Debug.out(AnBx_Layers.ALWAYS, "Error: " + msg);
		if (e != null) {
			AnBx_Debug.out(AnBx_Layers.ALWAYS, "Error description: " + e.toString());
			e.printStackTrace();
		}
		AnBx_Debug.out(AnBx_Layers.ALWAYS, " ----------------- Protocol Error ------------------- ");
	}

   	protected static void handleException(String msg, Exception e, Boolean terminate) {
		handleException(msg, e);
		if (terminate) System.exit(1);
	}


	protected static void status(AnBx_From_A_secret_for_B_C_honest_Steps step) {
		AnBx_Debug.out(layer, "Step: " + step.toString());
	}
	
    protected static void readStreamsSimple(String filepattern) {
        List<Map.Entry<Integer, Object>> streamObjects = readFilesWithPattern(filepattern);
        
        for (Map.Entry<Integer, Object> entry : streamObjects) {
            int streamNumber = entry.getKey();
            Object obj = entry.getValue();
            AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Object: " + obj);
        }
    }

    protected static void readStreams(String filepattern) {
        
        AnBx_Debug.out(layer, "--- Reading Streams ---");

        List<Map.Entry<Integer, Object>> streamObjects = readFilesWithPattern(filepattern);
        
        if (streamObjects.size() != steps.length) {
            handleException("Number of objects (" + streamObjects.size() + ") does not match the number of steps (" + steps.length + ")", null, true);
        } else {
        
            AnBx_Debug.out(layer, "--- Matching Messages and Steps ---");
            // Map to keep track of the steps already seen for each channel
            Map<AnBx_From_A_secret_for_B_C_honest_Channels, List<AnBx_From_A_secret_for_B_C_honest_Steps>> channelStepsSeenMap = new HashMap<>();
            String filename = null;
            
            for (Map.Entry<Integer, Object> entry : streamObjects) {
                int streamNumber = entry.getKey();
                Object obj = entry.getValue();
                
                // Find the channel corresponding to the stream number
                AnBx_From_A_secret_for_B_C_honest_Channels channel = channels[streamNumber]; 
                
                AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Channel: " + channel.toString());
                
                // Get the list of steps already seen for the current channel
                List<AnBx_From_A_secret_for_B_C_honest_Steps> stepsSeen = channelStepsSeenMap.getOrDefault(channel, new ArrayList<>());
                
                // Retrieve the steps associated with the current channel from the channelStepMap
                AnBx_From_A_secret_for_B_C_honest_Steps[] steps = channelStepMap.entrySet().stream()
                                                .filter(e -> e.getValue() == channel)
                                                .map(Map.Entry::getKey)
                                                .sorted(Comparator.comparingInt(Enum::ordinal)) // Sort steps by their ordinal value
                                                .toArray(AnBx_From_A_secret_for_B_C_honest_Steps[]::new);
                
                // Find the first step in the list of steps associated with the channel that hasn't been seen yet
                AnBx_From_A_secret_for_B_C_honest_Steps currentStep = null;
                for (AnBx_From_A_secret_for_B_C_honest_Steps step : steps) {
                    if (!stepsSeen.contains(step)) {
                        currentStep = step;
                        break;
                    }
                }
                
                // If no unseen steps are found, raise an error
                if (currentStep == null) {
                    handleException("Step not found for Object: " + obj, null, true);
                }
                
                // Update the list of steps already seen for the current channel
                stepsSeen.add(currentStep);
                channelStepsSeenMap.put(channel, stepsSeen);

                AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Step: " + currentStep + " - Object: " + obj.toString());
                // save the object in serialised file
                filename = "AnBx_From_A_secret_for_B_C_honest_" + currentStep + ".ser";
                AnB_Crypto_Wrapper.writeObject(obj,filename);
                AnBx_Debug.out(layer, "Saving " + filename);
            }
        }
    }

    public static List<Map.Entry<Integer, Object>> readFilesWithPattern(String pattern) {
            List<Map.Entry<Integer, Object>> objects = new ArrayList<>();
            int streamNumber = 0;

            File folder = new File(".");
            File[] listOfFiles = folder.listFiles((dir, name) -> name.matches(pattern));
            
            if (listOfFiles.length != channels.length) {
                handleException("Warning: Number of stream files (" + listOfFiles.length + ") does not match the number of channels (" + channels.length + ")", null, false);
            } else {
            
                    if (listOfFiles != null) {
                        for (File file : listOfFiles) {
                            AnBx_Debug.out(layer, "File: " + file.getName().toString());
                            try (FileInputStream fi = new FileInputStream(file);
                                ObjectInputStream oi = new ObjectInputStream(fi)) {

                                int objectNumber = 1;
                                while (true) {
                                    Object x = oi.readObject();
                                    AnBx_Debug.out(layer, "Stream #" + streamNumber + " - Object #" + objectNumber + ": " + x.getClass().toString() + " - " +  x.toString());
                                    objects.add(Map.entry(streamNumber, x));
                                    objectNumber++;
                                }
                            } catch (EOFException e) {
                            } catch (FileNotFoundException e) {
                                System.out.println("File not found: " + file.getName());
                                e.printStackTrace();
                            } catch (IOException e) {
                                System.out.println("IO exception: " + file.getName());
                                e.printStackTrace();
                            } catch (ClassNotFoundException e) {
                                System.out.println("Class not found: " + file.getName());
                                e.printStackTrace();
                            }
                            streamNumber++;
                        }
                    }
                }
                return objects;
        }    
        
    }